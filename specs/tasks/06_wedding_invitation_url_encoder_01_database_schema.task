# Task: Design Database Schema (ERD)

**Task ID:** `06_wedding_invitation_url_encoder_01_database_schema`  
**Plan:** `06_wedding_invitation_url_encoder.plan`  
**Phase:** Phase 1 - Database Design  
**Status:** ðŸ“ Todo  
**Created:** 2025-11-12  
**Last Updated:** 2025-11-12

---

## ðŸ“‹ Task Overview

**Title:** Design Database Schema & ERD for Wedding URLs  
**Priority:** ðŸ”´ Critical  
**Estimate:** 1 hour  
**Actual Time:** -

**Description:**  
Táº¡o ERD (Entity-Relationship Diagram) cho table `wedding_urls` vÃ  document quan há»‡ vá»›i `users` table. Diagram nÃ y sáº½ lÃ  foundation cho database migration vÃ  giÃºp team hiá»ƒu data model.

**Assigned To:** Database Developer  
**Due Date:** Day 1 (Phase 1)

---

## ðŸŽ¯ Objectives

1. **Primary Objective**
   - Táº¡o ERD diagram cho `wedding_urls` table vá»›i Ä‘áº§y Ä‘á»§ columns, data types, vÃ  relationships
   - Document indexes vÃ  constraints
   - Visualize soft delete pattern vá»›i `deleted_at` column

2. **Secondary Objectives**
   - Document example queries
   - Identify potential performance bottlenecks
   - Plan for future scalability

---

## âœ… Acceptance Criteria

- [ ] ERD diagram hoÃ n chá»‰nh vá»›i:
  - Table `wedding_urls` cÃ³ Ä‘áº§y Ä‘á»§ 6 columns (id, user_id, base_url, created_at, updated_at, deleted_at)
  - Foreign key relationship Ä‘áº¿n `users(id)`
  - 2 indexes visualization (user_id, deleted_at)
  - Data types rÃµ rÃ ng (UUID, VARCHAR, TIMESTAMP)
  - Primary key vÃ  constraints
  
- [ ] Soft delete pattern Ä‘Æ°á»£c document rÃµ rÃ ng
  - Logic: `deleted_at IS NULL` = active record
  - `deleted_at IS NOT NULL` = deleted record
  
- [ ] ERD diagram saved to `docs/diagrams/wedding_urls_erd.png` hoáº·c `.svg`

- [ ] Schema documentation includes:
  - Column descriptions
  - Index justification
  - Cascade delete behavior

---

## ðŸ“ Subtasks

### ERD Creation
- [ ] **Subtask 1.1:** Choose ERD tool
  - Options: dbdiagram.io, draw.io, Mermaid, Lucidchart
  - Recommendation: dbdiagram.io (nhanh, code-based, export PNG)
  
- [ ] **Subtask 1.2:** Define table structure
  - Table name: `wedding_urls`
  - 6 columns with correct data types
  - Primary key: `id UUID`
  - Foreign key: `user_id UUID -> users(id)`
  
- [ ] **Subtask 1.3:** Add indexes
  - Index 1: `idx_wedding_urls_user_id` on `user_id` (query by user)
  - Index 2: `idx_wedding_urls_deleted_at` on `deleted_at` (filter active)
  
- [ ] **Subtask 1.4:** Add constraints
  - NOT NULL: `user_id`, `base_url`, `created_at`, `updated_at`
  - NULLABLE: `deleted_at` (null = active record)
  - CASCADE: ON DELETE CASCADE for `user_id` FK

### Documentation
- [ ] **Subtask 1.5:** Create schema doc
  - File: `docs/database/wedding_urls_schema.md`
  - Document each column purpose
  - Document soft delete logic
  
- [ ] **Subtask 1.6:** Add example queries
  - Get latest active URL for user
  - Soft delete URL
  - Count URLs per user

### Validation
- [ ] **Subtask 1.7:** Review with team
  - Verify schema matches spec requirements
  - Check index strategy is optimal
  - Confirm soft delete pattern

---

## ðŸ“‚ Files to Create

### New Files
```
docs/diagrams/wedding_urls_erd.png          - ERD visualization
docs/database/wedding_urls_schema.md        - Schema documentation
```

---

## ðŸ”§ Implementation Details

### ERD Structure (dbdiagram.io code)

```dbml
// Use at https://dbdiagram.io/

Table users {
  id uuid [pk]
  email varchar(255)
  name varchar(255)
  created_at timestamp
}

Table wedding_urls {
  id uuid [pk, default: `uuid_generate_v4()`]
  user_id uuid [not null, ref: > users.id]
  base_url varchar(500) [not null]
  created_at timestamp [default: `now()`]
  updated_at timestamp [default: `now()`]
  deleted_at timestamp [null]
  
  Indexes {
    user_id [name: 'idx_wedding_urls_user_id']
    deleted_at [name: 'idx_wedding_urls_deleted_at']
  }
}

Ref: wedding_urls.user_id > users.id [delete: cascade]
```

### Schema Documentation Template

```markdown
# wedding_urls Table Schema

## Overview
Stores base URL for wedding invitation links. Each user can have one active URL at a time (soft delete pattern).

## Columns

| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| id | UUID | NO | uuid_generate_v4() | Primary key |
| user_id | UUID | NO | - | Foreign key to users.id (CASCADE DELETE) |
| base_url | VARCHAR(500) | NO | - | Base invitation URL (e.g., https://invitations.jmiiwedding.com/longnhiwedding) |
| created_at | TIMESTAMP | NO | NOW() | Record creation timestamp |
| updated_at | TIMESTAMP | NO | NOW() | Last update timestamp (auto-updated via trigger) |
| deleted_at | TIMESTAMP | YES | NULL | Soft delete timestamp. NULL = active, NOT NULL = deleted |

## Indexes

### idx_wedding_urls_user_id
- **Column:** user_id
- **Type:** B-tree
- **Purpose:** Fast lookup of user's URLs
- **Query:** `SELECT * FROM wedding_urls WHERE user_id = ? AND deleted_at IS NULL`

### idx_wedding_urls_deleted_at
- **Column:** deleted_at
- **Type:** B-tree
- **Purpose:** Efficiently filter active records
- **Query:** `WHERE deleted_at IS NULL`

## Soft Delete Pattern

**Active Record:** `deleted_at IS NULL`  
**Deleted Record:** `deleted_at IS NOT NULL`

When user saves new URL:
1. Soft delete old URL: `UPDATE wedding_urls SET deleted_at = NOW() WHERE user_id = ? AND deleted_at IS NULL`
2. Insert new URL: `INSERT INTO wedding_urls (user_id, base_url) VALUES (?, ?)`

This preserves history while maintaining "one active URL per user" constraint.

## Relationships

- **users (1) â†’ wedding_urls (many):** One user can have multiple URLs (but only one active)
- **Cascade Delete:** When user is deleted, all their wedding_urls are deleted

## Example Queries

### Get Latest Active URL
```sql
SELECT id, base_url, created_at 
FROM wedding_urls 
WHERE user_id = $1 AND deleted_at IS NULL 
ORDER BY created_at DESC 
LIMIT 1;
```

### Soft Delete URL
```sql
UPDATE wedding_urls 
SET deleted_at = NOW(), updated_at = NOW() 
WHERE id = $1 AND user_id = $2 AND deleted_at IS NULL;
```

### Get User's URL History (including deleted)
```sql
SELECT id, base_url, created_at, deleted_at 
FROM wedding_urls 
WHERE user_id = $1 
ORDER BY created_at DESC;
```

## Performance Considerations

- **Index on user_id:** Speeds up query by user (most common operation)
- **Index on deleted_at:** Speeds up filtering active records
- **Soft delete vs hard delete:** Preserves audit trail, minimal storage overhead
- **Expected cardinality:** 1-5 URLs per user (low), indexes are efficient

## Future Scalability

- **Partitioning:** Not needed initially (< 1M records expected)
- **Archiving:** Consider moving deleted_at NOT NULL records to archive table after 1 year
- **Additional indexes:** Add index on `created_at` if history queries become common
```

---

## ðŸ§ª Testing Plan

### Validation Checks
- [ ] **Visual Review:** ERD is clear and readable
- [ ] **Completeness:** All 6 columns present with correct types
- [ ] **Relationships:** Foreign key to users is correct
- [ ] **Indexes:** Both indexes are documented
- [ ] **Soft Delete:** Logic is clear and correct

### Peer Review
- [ ] Share ERD with team
- [ ] Gather feedback on schema design
- [ ] Verify alignment with spec requirements
- [ ] Confirm no missing fields or indexes

---

## ðŸ”— Dependencies

### Blocking Dependencies
- [ ] `users` table must exist in database (already exists)
- [ ] `uuid-ossp` extension enabled (for uuid_generate_v4())

### Related Tasks
- Task 02: Write migration scripts (depends on this schema)
- Task 03: Test migration (depends on Task 02)

---

## ðŸ“ Notes

### Technical Notes
- **UUID vs SERIAL:** Using UUID for global uniqueness and better data portability
- **VARCHAR(500) for base_url:** Most URLs < 200 chars, 500 allows room for long domains/paths
- **Soft delete vs hard delete:** Preserves audit trail, enables "undo" feature later
- **Single active URL:** Simplifies UX, users rarely need multiple simultaneous events

### Design Decisions
1. **Why soft delete instead of hard delete?**
   - Preserves user history
   - Enables potential "restore" feature
   - Minimal storage cost
   - Standard pattern in the project

2. **Why index on deleted_at?**
   - Most queries filter `WHERE deleted_at IS NULL`
   - Without index, full table scan on every query
   - B-tree index on nullable column is efficient

3. **Why CASCADE DELETE on user_id?**
   - User deletion should remove all their data
   - GDPR compliance (right to be forgotten)
   - Prevents orphaned records

### Resources
- [dbdiagram.io Documentation](https://dbdiagram.io/docs)
- [PostgreSQL Index Types](https://www.postgresql.org/docs/current/indexes-types.html)
- [Soft Delete Pattern](https://en.wikipedia.org/wiki/Soft_deletion)

---

## âœ… Checklist Before Marking Done

### Design Quality
- [ ] ERD follows database normalization rules
- [ ] All relationships are correct (1:many from users)
- [ ] Data types are appropriate for data
- [ ] Indexes are justified by query patterns

### Documentation
- [ ] ERD diagram exported and saved
- [ ] Schema documentation is complete
- [ ] Example queries are correct
- [ ] Soft delete logic is clear

### Review
- [ ] Self-review complete
- [ ] Team review requested
- [ ] Feedback incorporated
- [ ] Approved by technical lead

---

## ðŸ”„ Progress Log

### 2025-11-12 - Created
- Task created from Phase 1 of implementation plan
- Ready to start ERD design

---

## ðŸŽ¯ Deliverables

- [x] ERD diagram: `docs/diagrams/wedding_urls_erd.png`
- [x] Schema doc: `docs/database/wedding_urls_schema.md`
- [x] Team review complete
- [x] Ready for migration script writing (Task 02)

**Completed By:** -  
**Completion Date:** -  
**Time Taken:** - hours

---

**Next Task:** `06_wedding_invitation_url_encoder_02_migration_scripts`  
**Related Plan:** `plans/06_wedding_invitation_url_encoder.plan`  
**Related Spec:** `specs/06_wedding_invitation_url_encoder.spec`
